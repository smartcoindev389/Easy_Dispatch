## 1) Quote creation flow (frontend → backend → carrier → Firestore)

**What it does**
User submits origin/destination postal codes and package details. Backend validates, calls Frenet adapter, computes `finalPrice` using server-side margin logic, persists the quote to Firestore and returns a normalized response.

**How to test**

Manual / Exploratory

* In the frontend, fill the Quote form and submit. Confirm spinner shown, then a result with `negotiatedCost` and `finalPrice`. Note `correlationId`.
* In Firebase console or emulator UI, verify a document was created under `/clients/{clientId}/quotes/{quoteId}` with `request`, `carrierResponse`, `negotiatedCost`, `finalPrice`, `status: "success"`.

Automated

* Unit test billing service: call `calculateFinalPrice(negotiatedCost)` with values `0`, `10.5`, `999999`, negative number. Assert correct rounding and error handling.
* Integration test with mocked Frenet HTTP responses (Jest + nock or msw): POST `/api/quotes` and assert:

  * response code 200
  * body contains `quoteId`, `prices` array with `finalPrice`
  * Firestore emulator contains the quote doc and fields match

Example curl (backend staging)

```bash
curl -X POST https://staging.example.com/api/quotes \
 -H "Authorization: Bearer <JWT>" \
 -H "Content-Type: application/json" \
 -d '{
   "originPostal":"01001000",
   "destPostal":"20040002",
   "weight":1.2,
   "length":10,"width":10,"height":10
 }'
```

Expected: JSON with `quoteId`, `prices[0].finalPrice` and `correlationId`.

Failure modes to test

* Frenet times out → backend returns 502 with `{ code: "CARRIER_TIMEOUT", correlationId }` and Firestore doc with `status: "carrier_timeout"`.
* Invalid input (bad postal code) → 400 with validation error showing field and message.

---

## 2) Server-side margin / billing logic

**What it does**
Applies formula `finalPrice = negotiatedCost * MARKUP_PERCENT + FIXED_FEE` consistently on the backend.

**How to test**

Automated

* Unit tests that cover:

  * normal values
  * zero and very small negotiatedCost
  * very large values to check overflow/precision
  * negative negotiatedCost (should throw or reject)
  * rounding: assert two decimal places

Test example (Jest)

```ts
expect(calculateFinalPrice(10)).toBeCloseTo(10*1.2 + 5, 2);
```

Manual

* Submit a quote with a mocked negotiatedCost (via mocked Frenet response) and verify `finalPrice` returned matches the formula and persisted doc matches.

---

## 3) Carrier adapter (Frenet)

**What it does**
Transforms normalized request into Frenet API calls, sends token in headers/body, normalizes response back to internal format.

**How to test**

Automated

* Adapter unit tests with HTTP mocking:

  * success response mapping to `negotiatedCost`, `service`, `estimatedDeliveryDays`
  * vendor returns an authentication error → adapter throws `CARRIER_AUTH_ERROR`
  * vendor returns malformed JSON → adapter throws `CARRIER_ERROR`
  * vendor slow response → adapter times out and throws `CARRIER_TIMEOUT`

Integration

* If possible, use a real Frenet test token or a staging account to verify live responses. Otherwise use the mocked responses.

Example adapter health curl (backend-only ping call)

* Implement a `/api/carriers/frenet/test` admin endpoint (dev only) to validate token; call it and expect 200.

---

## 4) Persistence and client isolation (Firestore + security rules)

**What it does**
Saves quotes per client and ensures each client can only read their own quotes.

**How to test**

Manual

* From frontend logged in as client A, create a quote; then attempt to fetch quotes as client B (different JWT). Client B should get empty list or 403 depending on endpoint design.

Automated

* Firestore security rules unit tests using Firebase emulator and `@firebase/testing`:

  * write as client A, read as client A → allowed
  * read as client B → denied
  * attempt direct write bypassing backend (simulate) → denied if auth missing or clientId mismatch

Acceptance rule

* `request.auth.token.clientId` must match document path `clients/{clientId}`.

---

## 5) Real-time quote updates (onSnapshot behavior)

**What it does**
Dashboard should update when new quotes are created without manual refresh.

**How to test**

Manual

* Open Dashboard in one browser. In another, submit a new quote. Verify Dashboard updates within a couple of seconds.

Automated

* Use Firestore emulator and a realtime client to subscribe and assert that when a new quote is written the subscription callback receives the new doc. You can write tests that:

  * start listener
  * write doc to emulator
  * await listener callback and assert data



---

## 6) Auth and authorization

**What it does**
Protects endpoints with JWT or API tokens; attaches `clientId` to requests.

**How to test**

Automated

* Tests for protected routes:

  * no token → 401
  * invalid token → 401
  * valid token but clientId mismatch → 403 when accessing other client data
  * expired token → 401

Manual

* Try the same curl request without Authorization header; expect 401.

---

## 7) Timeouts, retries and circuit breaker behavior

**What it does**
Prevents frontend hanging when carrier is slow and avoids overloading dead services.

**How to test**

Automated / Integration

* Configure adapter timeout to a low value (e.g., 100 ms) in test and mock an endpoint that sleeps longer → expect `CARRIER_TIMEOUT` and persisted `status: carrier_timeout`.
* Simulate repeated failures to hit circuit breaker threshold and assert subsequent calls return fast failure.

Manual

* Temporarily point Frenet adapter to a slow test server and submit quote; verify response returns an error quickly and logs correlationId.

---

## 8) Label generation stub

**What it does**
Returns a generated label stub for MVP (PDF or URL) when requested.

**How to test**

Manual

* Call `POST /api/labels` with a valid `quoteId`. Expect a generated PDF link or base64 content. Download and visually inspect.

Automated

* Integration test: call `/api/labels` for existing quote, assert response contains `labelUrl` or `pdfBase64` and stored metadata in Firestore status updated to `label_generated`.

---

## 9) Logging, error tracking and correlationId

**What it does**
All requests generate correlationId included in response and logs for troubleshooting.

**How to test**

Manual

* Trigger an error (carrier timeout) and note the correlationId in the frontend error banner. Inspect backend logs to confirm the same correlationId is present with error details.

Automated

* Integration test that asserts error response contains `correlationId` and that the saved Firestore error doc includes the same id.

---

## 10) Frontend behaviors to test (debounce, loading, error UI)

**What it does**
Debounces postal input, shows loader during quote call, shows friendly error with correlationId, and never exposes secrets.

**How to test**

Manual

* Type rapidly into postal code input and observe that backend receives only debounced calls (use browser devtools Network tab).
* Submit while offline or simulate 502 and verify ErrorBanner shows correlationId.

Automated / E2E

* Playwright/Cypress scenario:

  * visit Quote page
  * fill the form and submit
  * assert that loader shows, then result appears
  * simulate server error (mock) and assert error UI shows correlationId and retry button

Security test

* Build production bundle and search for `FRENET_API_KEY` or token strings to ensure they are not embedded.

---

## 11) CI tests and emulators to run locally

**Recommended local test stack**

* Firestore emulator (part of Firebase CLI)
* Run Jest unit tests
* Start NestJS in test mode with Firestore emulator config
* Use nock or msw to mock Frenet in automated integration tests

Basic commands

```bash
# install firebase tools if needed
npm install -g firebase-tools

# start firestore emulator (in project folder)
firebase emulators:start --only firestore

# run unit tests
npm test

# run integration tests pointing to emulator
FIRESTORE_EMULATOR_HOST=localhost:8080 npm run test:integration
```

---

## 12) Test matrix and priority (quick checklist)

Run these tests at minimum before any client demo:

High priority

* Quote happy path end-to-end with staging Frenet or mocked response
* Server-side billing unit tests
* Auth guard tests for 401 / 403
* Firestore security rules test for client isolation
* Carrier timeout behavior test

Medium priority

* Real-time subscription test on dashboard
* Label generation test
* Circuit breaker behavior after repeated failures

Low priority

* Visual regression and accessibility checks
* Performance under load (basic load test for concurrent quote requests)

---

## Example automated test snippet (Jest + supertest + Firestore emulator)

```ts
// example integration test outline
it('creates a quote and persists to firestore', async () => {
  // mock Frenet HTTP to return negotiatedCost 10.00
  mockFrenetResponse({ negotiatedCost: 10.00 });

  const res = await request(app.getHttpServer())
    .post('/api/quotes')
    .set('Authorization', `Bearer ${testJwt}`)
    .send(validQuotePayload);

  expect(res.status).toBe(200);
  expect(res.body.prices[0].finalPrice).toBeCloseTo(10 * 1.2 + 5, 2);
  // verify document in emulator
  const doc = await firestore.collection('clients').doc(testClientId)
    .collection('quotes').doc(res.body.quoteId).get();
  expect(doc.exists).toBe(true);
  expect(doc.data().finalPrice).toBeCloseTo(10 * 1.2 + 5, 2);
});
```

---

## Practical tips before testing

1. Never use real production tokens on local machines. Use a staging Frenet token or mock responses.
2. Use Firestore emulator for automated tests to avoid cost and accidental data pollution.
3. Sanitize logs in CI to avoid leaking secrets. Mask `FRENET_API_KEY` when logging request headers.
4. Keep your `MARKUP_PERCENT` and `FIXED_FEE` configurable and covered by unit tests to verify business changes quickly.

---

